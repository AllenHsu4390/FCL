(define (record-constructor-invoker rec-type)
  (add-record-type rec-type)
  (let* ((alias (grecord-type-alias rec-type))
         (inputs (record-arg->base-args (ast-arg 0 alias)))
         (output (ast-arg (length inputs) alias))
         (cname (assign-glambda-name))
         (gproc-order (order-counter)))
    (lambda args
      (let* ((gproc (gprocedure (flatlist inputs output)
                                (ast-record "rtn"
                                            inputs
                                            rec-type
                                            (order-counter))
                                gproc-order))
             (local (gprocedure->cprogram-string cname gproc))
             (operation (user-function cname gproc #f local)))
        (add-user-function operation)
        (declare-variable (function-call/user operation args))))))

(define (record-pred-invoker record-type)
  (lambda (arg)
    (g= (gbase-id arg) (grecord-type-order record-type))))

(define (record-accessor-invoker property record-type)
  (lambda (arg)
    (accessor-call property arg record-type)))

(define (call-invoker name #!optional type)
  (lambda args
    (function-call name args type)))

(define (call-invoker/binary name)
  (lambda args
    (binary-call name args)))

(define (call-invoker/tertiary name1 name2)
  (lambda (arg1 arg2 arg3)
    (tertiary-call name1 name2 (list arg1 arg2 arg3))))

(define (call-invoker/dereference lst index)
  (dereference-call lst index))

(define (call-invoker/user proc #!optional name kernel)
  (let* ((cname (or name (assign-glambda-name)))
         (proc-args (scope-args proc))
         (proc (scope-gprocedure proc proc-args))
         (local (gprocedure->cprogram-string cname proc)))
    (lambda args
      (let* ((operation (user-function cname proc kernel local))
             (call (function-call/user operation (flatlist args proc-args))))
        (cond ((any list-arg? args)
               (rewrite-call call))
              (else
               (begin (add-user-function operation)
                      call)))))))

(define (declare-variable tree)
  (if (and (ast-call/user? tree) (ast-call-type tree))
      (ast-variable (ast-call-type tree)
                    (assign-variable-name)
                    tree
                    (order-counter))
      tree))

(define (function-call/user operation args)
  (ast-call operation
            (gprocedure-output-type (user-function-procedure operation))
            (map clean-argument args)))

(define (function-call/map type invoker args)
  (let* ((clean-args (map clean-argument args))
         (arg-count (length clean-args))
         (size (glist-size (car clean-args)))
         (mk-arg (lambda (i t) (ast-arg i (pointer-type t) size)))
         (arg-numbers (iota arg-count))
         (arg-types (map dynamic-space-type clean-args))
         (scope-args (extract-scope-args invoker clean-args))
         (proc-inputs (map mk-arg arg-numbers arg-types))
         (proc-output (mk-arg arg-count type))
         (memory-instance (ast-list (assign-glist-name) type size '() (order-counter)))
         (op (map-operation (ast-arg-name proc-output) invoker type (order-counter)))
         (proc-args (flatlist proc-inputs proc-output))
         (call-args (flatlist proc-inputs scope-args))
         (wrapper-args (flatlist clean-args memory-instance))
         (map-call (ast-call op type call-args))
         (map-gprocedure (gprocedure proc-args map-call (order-counter))))
    ((call-invoker/user map-gprocedure) wrapper-args)))

(define (function-call/fold type invoker args start left?)
  (let* ((clean-start (clean-argument start))
         (clean-args (map clean-argument args))
         (name (assign-functor-name))
         (op (fold-operation name invoker clean-start type left? (order-counter)))
         (arg-count (length clean-args))
         (size (glist-size (car clean-args)))
         (mk-arg (lambda (i t) (ast-arg i (pointer-type t) size)))
         (arg-numbers (iota arg-count))
         (arg-types (map dynamic-space-type clean-args))
         (scope-args (extract-scope-args invoker clean-args))
         (proc-inputs (flatlist (map mk-arg arg-numbers arg-types)))
         (proc-output (ast-arg (+ 1 arg-count) type))
         (proc-args (flatlist proc-inputs proc-output))
         (call-args (flatlist proc-inputs scope-args))
         (wrapper-args (flatlist clean-args))
         (fold-call (ast-call op type call-args))
         (fold-gprocedure (gprocedure proc-args fold-call (order-counter))))
    ((call-invoker/user fold-gprocedure) wrapper-args)))

(define (rewrite-tree tree)
  (cond ((ast-call? tree)
         (rewrite-call tree))
        ((ast-variable? tree)
         (rewrite-tree (ast-variable-arg tree)))
        (else
         tree)))

(define (invoker->ast-call func args)
  (let ((rtn (apply func args)))
    (if (ast-variable? rtn)
        (ast-variable-arg rtn)
        rtn)))

(define (binary-call cname args)
  (let ((clean-args (map clean-argument args)))
    (ast-call (binary cname)
              (dynamic->type clean-args)
              clean-args)))

(define (tertiary-call cname1 cname2 args)
  (let ((clean-args (map clean-argument args)))
    (ast-call (tertiary cname1 cname2)
              (dynamic->type clean-args)
              clean-args)))

(define (dereference-call lst index)
  (let ((clean (clean-argument lst)))
    (ast-call (dereference)
              (ast-type clean)
              (list clean (clean-argument index)))))

(define (function-call cname args #!optional type)
  (let ((clean-args (map clean-argument args)))
    (ast-call (function cname)
              (if type type (dynamic->type clean-args))
              clean-args)))


(define (accessor-call prop arg record-type)
  (let ((op (struct-access prop record-type)))
    (ast-call op
              (struct-access-property-type op)
              (list (clean-argument arg)))))

(define (ast-list-clean-copy x)
  (ast-list (ast-list-name x)
            (ast-list-type x)
            (ast-list-size x)
            (map clean-argument (ast-list-args x))
            (ast-list-order x)))

(define (ast-constant-clean-copy x)
  (define rtn
    (ast-constant (ast-constant-name x)
                  (ast-constant-type x)
                  (ast-constant-size x)
                  (map clean-argument (ast-constant-args x))
                  (ast-constant-order x)))
  (add-constant rtn)
  rtn)

(define (ast-literal-copy x)
  (ast-literal x #f))

(define (clean-argument arg)
  (let* ((self (lambda (x) x))
         (make-ast (case-cond arg
                     (ast-call? self)
                     (ast-arg? self)
                     (ast-record? self)
                     (ast-variable? self)
                     (ast-literal? self)
                     (ast-shared? self)
                     (ast-list? ast-list-clean-copy)
                     (ast-constant? ast-constant-clean-copy)
                     (else ast-literal-copy))))
    (make-ast arg)))

(define (extract-scope-args invoker args)
  (let* ((extract-args (lambda (a) (extract-ast-type a ast-arg?)))
         (call (invoker->ast-call invoker '())))
    (delete-duplicates (flatlist (map extract-args args)
                                 (map extract-args (ast-call-args call))))))

(define (rewrite-call call)
  (let ((type (ast-call-type call))
        (args (ast-call-args call))
        (op (ast-call-operation call)))
    (if (ast-call/user? call)
        (let* ((name (user-function-name op))
               (proc (user-function-procedure op))
               (kernel (user-function-kernel op))
               (inst (gprocedure-instance name proc args))
               (inst-name (car inst))
               (inst-proc (cdr inst))
               (inst-local (gprocedure->cprogram-string inst-name inst-proc))
               (inst-operation (user-function inst-name inst-proc kernel inst-local)))
          (if (not (string=? name inst-name))
              (add-user-function inst-operation))
          (function-call/user inst-operation (map rewrite-tree args)))
        (ast-call op type (map rewrite-tree args)))))
